{"version":3,"file":"index_BeN_NuJi.mjs","sources":["../../../src/locales/index.ts"],"sourcesContent":["export type TransStrings = typeof import(\"./en\").default;\nexport type TransKey = ObjectToDotProp<TransStrings>;\n\ntype Unstricten<T> = {\n    [K in keyof T]: T[K] extends Record<string, unknown>\n        ? Unstricten<T[K]>\n        : T[K] extends string\n        ? string\n        : T[K];\n};\n\ntype ResolvePropDeep<T, P> = P extends \"\"\n    ? T\n    : P extends `${infer Pre}.${infer Suf}`\n    ? Pre extends keyof T\n        ? ResolvePropDeep<T[Pre], Suf>\n        : never\n    : P extends keyof T\n    ? T[P]\n    : never;\n\ntype ObjectToDotProp<T extends object> = ObjectToDotPropInternal<T>[keyof T];\n\ntype ObjectToDotPropInternal<T extends object> = {\n    [Key in keyof T]: Key extends string\n        ? T[Key] extends Record<string, unknown>\n            ? ObjectToDotProp<T[Key]> extends string\n                ? // @ts-ignore \"Type instantiation is excessively deep and possibly infinite\"\n                  `${Key}.${ObjectToDotProp<T[Key]>}`\n                : never\n            : Key\n        : never;\n};\n\nexport function defineLocale(strings: Unstricten<TransStrings>) {\n    return strings;\n}\n\nconst LocaleStrings = {\n    // de: () => import(\"./de\"),\n    en: () => import(\"./en\"),\n};\n\nexport const Locales = Object.keys(LocaleStrings);\n\nexport const getStaticPaths = () =>\n    Object.keys(LocaleStrings).map(lang => ({ params: { lang } }));\n\ntype t = <Trans extends TransKey>(\n    trans: Trans,\n    params?: Record<string, string>\n) => ResolvePropDeep<TransStrings, Trans>;\n\nexport async function loadStrings(\n    locale: string | undefined\n): Promise<t | null>;\nexport async function loadStrings(\n    locale: string | undefined,\n    throwIfMissing: true\n): Promise<t>;\nexport async function loadStrings(\n    locale: string | undefined,\n    throwIfMissing = false\n): Promise<t | null> {\n    if (!locale || !LocaleStrings[locale]) {\n        if (throwIfMissing) throw new Error(\"Invalid locale \" + locale);\n        return null;\n    }\n\n    const { default: strings } = await LocaleStrings[locale]();\n\n    return function <Trans extends TransKey>(\n        trans: Trans,\n        params?: Record<string, string>\n    ): ResolvePropDeep<TransStrings, Trans> {\n        let v: any = strings;\n        for (const path of trans.split(\".\")) {\n            v = v[path];\n            if (!v) throw new Error(\"Missing translation \" + trans);\n        }\n\n        if (typeof v !== \"string\")\n            throw new Error(\"Missing translation \" + trans);\n\n        if (params)\n            for (const [key, value] of Object.entries(params)) {\n                v = v.replaceAll(`{{${key}}}`, value);\n            }\n\n        return v;\n    };\n}\n"],"names":[],"mappings":"AAsCA,MAAM,aAAgB,GAAA;AAAA;AAAA,EAElB,EAAA,EAAI,MAAM,OAAO,mBAAM;AAC3B,CAAA;AAEa,MAAA,OAAA,GAAU,MAAO,CAAA,IAAA,CAAK,aAAa;AAEzC,MAAM,cAAiB,GAAA,MAC1B,MAAO,CAAA,IAAA,CAAK,aAAa,CAAA,CAAE,GAAI,CAAA,CAAA,IAAA,MAAS,EAAE,MAAA,EAAQ,EAAE,IAAA,IAAS,CAAA;AAc3C,eAAA,WAAA,CAClB,MACA,EAAA,cAAA,GAAiB,KACA,EAAA;AACjB,EAAA,IAAI,CAAC,MAAA,IAAU,CAAC,aAAA,CAAc,MAAM,CAAG,EAAA;AACnC,IAAA,IAAI,cAAgB,EAAA,MAAM,IAAI,KAAA,CAAM,oBAAoB,MAAM,CAAA;AAC9D,IAAO,OAAA,IAAA;AAAA;AAGX,EAAA,MAAM,EAAE,OAAS,EAAA,OAAA,KAAY,MAAM,aAAA,CAAc,MAAM,CAAE,EAAA;AAEzD,EAAO,OAAA,SACH,OACA,MACoC,EAAA;AACpC,IAAA,IAAI,CAAS,GAAA,OAAA;AACb,IAAA,KAAA,MAAW,IAAQ,IAAA,KAAA,CAAM,KAAM,CAAA,GAAG,CAAG,EAAA;AACjC,MAAA,CAAA,GAAI,EAAE,IAAI,CAAA;AACV,MAAA,IAAI,CAAC,CAAG,EAAA,MAAM,IAAI,KAAA,CAAM,yBAAyB,KAAK,CAAA;AAAA;AAG1D,IAAA,IAAI,OAAO,CAAM,KAAA,QAAA;AACb,MAAM,MAAA,IAAI,KAAM,CAAA,sBAAA,GAAyB,KAAK,CAAA;AAElD,IAAI,IAAA,MAAA;AACA,MAAA,KAAA,MAAW,CAAC,GAAK,EAAA,KAAK,KAAK,MAAO,CAAA,OAAA,CAAQ,MAAM,CAAG,EAAA;AAC/C,QAAA,CAAA,GAAI,CAAE,CAAA,UAAA,CAAW,CAAK,EAAA,EAAA,GAAG,MAAM,KAAK,CAAA;AAAA;AAG5C,IAAO,OAAA,CAAA;AAAA,GACX;AACJ;;;;"}